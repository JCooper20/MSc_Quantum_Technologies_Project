# -*- coding: utf-8 -*-
"""Quantum_Tech_V2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11iLKsbdfmarlG2kDgXv0kV5a0fpsAQSy

# Quantum State Stabilization via Neural Network Control

#### Training a two-phase LSTM controller to create and maintain GHZ entangled states in monitored quantum circuits under measurement-induced decoherence.

Imports
"""

!pip install qiskit qiskit-aer scipy matplotlib torch -q
import numpy as np
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
from qiskit.quantum_info import Statevector, partial_trace, entropy, state_fidelity
from qiskit.quantum_info import Operator
import matplotlib.pyplot as plt
from typing import List, Tuple, Dict, Optional
from dataclasses import dataclass
import json
import pickle
from scipy.linalg import expm

"""Defining Circuit Parameters"""

@dataclass
class CircuitParams:
    """Parameters for the monitored quantum circuit"""
    L: int  # Number of qubits
    p_u: float  # Probability of applying unitary gate
    p_m: float  # Probability of measurement
    gamma: Optional[float] = None  # Measurement rate (alternative to p_m)
    periodic_bc: bool = False  # Periodic boundary conditions

    def __post_init__(self):
        if self.gamma is not None:
            self.p_m = self.gamma / self.L

"""Building Clifford Circuit"""

class BrickworkCircuit:
    """
    1D Brickwork Clifford Circuit for measurement-induced phase transitions
    with neural network control capabilities
    """

    def __init__(self, params: CircuitParams):
        self.params = params
        self.L = params.L
        self.p_u = params.p_u
        self.p_m = params.p_m
        self.periodic_bc = params.periodic_bc

        # Build the two-qubit entangling gate once
        self._build_entangling_gate()

        # History tracking
        self.measurement_history = []
        self.syndrome_history = []
        self.control_actions = []

    def _build_entangling_gate(self):
        """Build U_ij = exp(-i*pi/4 * (X_i X_j + Z_i Z_j))"""
        XX = np.array([[0, 0, 0, 1],
                       [0, 0, 1, 0],
                       [0, 1, 0, 0],
                       [1, 0, 0, 0]])

        ZZ = np.array([[1, 0, 0, 0],
                       [0, -1, 0, 0],
                       [0, 0, -1, 0],
                       [0, 0, 0, 1]])

        H = -1j * np.pi/4 * (XX + ZZ)
        self.U_entangle = expm(H)

    def initialize_plus_state(self) -> Statevector:
        """Initialize all qubits in |+⟩ state"""
        qc = QuantumCircuit(self.L)
        for i in range(self.L):
            qc.h(i)
        return Statevector(qc)

    def initialize_near_ghz(self, noise_level: float = 0.1) -> Statevector:
        """Initialize in a noisy GHZ state"""
        qc = QuantumCircuit(self.L)

        # Create perfect GHZ
        qc.h(0)
        for i in range(self.L - 1):
            qc.cx(i, i + 1)

        # Add noise
        for i in range(self.L):
            if np.random.random() < noise_level:
                error_type = np.random.choice(['x', 'z', 'h'])
                if error_type == 'x':
                    qc.x(i)
                elif error_type == 'z':
                    qc.z(i)
                else:
                    qc.h(i)

        return Statevector(qc)

    def initialize_random_entangled(self) -> Statevector:
        """Initialize in a random entangled state"""
        qc = QuantumCircuit(self.L)

        for i in range(self.L):
            if np.random.random() < 0.5:
                qc.h(i)

        for _ in range(self.L // 2):
            i = np.random.randint(0, self.L - 1)
            j = np.random.randint(0, self.L - 1)
            if i != j:
                qc.cx(i, j)

        return Statevector(qc)

"""Gate Operations"""

def apply_brickwork_layer(self, state: Statevector, layer_parity: int) -> Tuple[Statevector, List[Tuple[int, int]]]:
    """Apply two-qubit unitaries in brickwork pattern"""
    applied_gates = []

    if layer_parity == 0:
        bonds = [(2*k, 2*k+1) for k in range(self.L // 2)]
    else:
        bonds = [(2*k+1, 2*k+2) for k in range((self.L-1) // 2)]

    if self.periodic_bc and layer_parity == 1 and self.L % 2 == 0:
        bonds.append((self.L-1, 0))

    for i, j in bonds:
        if np.random.random() < self.p_u:
            state = self._apply_two_qubit_gate(state, i, j)
            applied_gates.append((i, j))

    return state, applied_gates

def _apply_two_qubit_gate(self, state: Statevector, i: int, j: int) -> Statevector:
    """Apply the entangling gate U_ij to qubits i and j"""
    from qiskit.circuit.library import UnitaryGate

    qc = QuantumCircuit(self.L)
    gate = UnitaryGate(self.U_entangle, label='U_ent')
    qc.append(gate, [i, j])

    return state.evolve(qc)

def measure_x_basis(self, state: Statevector, qubit_idx: int) -> Tuple[Statevector, int]:
    """Measure qubit in X basis"""
    qc = QuantumCircuit(self.L)
    qc.h(qubit_idx)

    state_rotated = state.evolve(qc)
    probs = state_rotated.probabilities()

    prob_0 = sum(probs[i] for i in range(2**self.L) if not (i >> qubit_idx) & 1)
    outcome = 0 if np.random.random() < prob_0 else 1

    state_vec = state_rotated.data
    new_state = np.zeros_like(state_vec)

    for i in range(2**self.L):
        bit_value = (i >> qubit_idx) & 1
        if bit_value == outcome:
            new_state[i] = state_vec[i]

    norm = np.linalg.norm(new_state)
    if norm > 1e-10:
        new_state = new_state / norm

    state_measured = Statevector(new_state)

    qc_back = QuantumCircuit(self.L)
    qc_back.h(qubit_idx)
    state_final = state_measured.evolve(qc_back)

    return state_final, outcome

def apply_measurement_layer(self, state: Statevector) -> Tuple[Statevector, List[Tuple[int, int]]]:
    """Apply X-basis measurements probabilistically"""
    measurements = []

    for i in range(self.L):
        if np.random.random() < self.p_m:
            state, outcome = self.measure_x_basis(state, i)
            measurements.append((i, outcome))

    return state, measurements

# Add methods to class
BrickworkCircuit.apply_brickwork_layer = apply_brickwork_layer
BrickworkCircuit._apply_two_qubit_gate = _apply_two_qubit_gate
BrickworkCircuit.measure_x_basis = measure_x_basis
BrickworkCircuit.apply_measurement_layer = apply_measurement_layer

"""Trajectory's and Observables"""

def run_single_timestep(self, state: Statevector, timestep: int) -> Tuple[Statevector, Dict]:
    """Run one time step of the circuit"""
    layer_parity = timestep % 2

    state, gates = self.apply_brickwork_layer(state, layer_parity)
    state, measurements = self.apply_measurement_layer(state)
    syndrome = self._compute_syndrome(state, measurements)

    record = {
        'timestep': timestep,
        'layer_parity': layer_parity,
        'gates_applied': gates,
        'measurements': measurements,
        'syndrome': syndrome,
        'num_gates': len(gates),
        'num_measurements': len(measurements)
    }

    return state, record

def _compute_syndrome(self, state: Statevector, measurements: List[Tuple[int, int]]) -> np.ndarray:
    """Compute syndrome for error detection"""
    syndrome = np.zeros(self.L)
    for qubit, outcome in measurements:
        syndrome[qubit] = outcome
    return syndrome

def run_trajectory(self, num_steps: int, verbose: bool = False) -> Tuple[Statevector, List[Dict]]:
    """Run complete trajectory"""
    state = self.initialize_plus_state()
    history = []

    if verbose:
        print(f"\n{'='*70}")
        print(f"Running trajectory: L={self.L}, p_u={self.p_u:.2f}, p_m={self.p_m:.3f}")
        print(f"{'='*70}")

    for step in range(num_steps):
        state, record = self.run_single_timestep(state, step)
        history.append(record)

        if verbose and step % 10 == 0:
            S = self.compute_entanglement_entropy(state, list(range(self.L//2)))
            print(f"Step {step:3d}: Gates={record['num_gates']}, "
                  f"Meas={record['num_measurements']}, S(L/2)={S:.4f}")

    if verbose:
        print(f"{'='*70}\n")

    return state, history

def compute_entanglement_entropy(self, state: Statevector, subsystem: List[int]) -> float:
    """Compute von Neumann entropy"""
    if len(subsystem) == 0 or len(subsystem) == self.L:
        return 0.0

    complement = list(set(range(self.L)) - set(subsystem))

    try:
        rho_A = partial_trace(state, complement)
        S = entropy(rho_A, base=2)
        return S
    except:
        return 0.0

def compute_mutual_information(self, state: Statevector, i: int, j: int) -> float:
    """Compute I(i:j) = S(i) + S(j) - S(i,j)"""
    S_i = self.compute_entanglement_entropy(state, [i])
    S_j = self.compute_entanglement_entropy(state, [j])
    S_ij = self.compute_entanglement_entropy(state, [i, j])
    return S_i + S_j - S_ij

def compute_tripartite_information(self, state: Statevector, i: int, j: int, k: int) -> float:
    """Compute I₃(i:j:k)"""
    S_i = self.compute_entanglement_entropy(state, [i])
    S_j = self.compute_entanglement_entropy(state, [j])
    S_k = self.compute_entanglement_entropy(state, [k])
    S_ij = self.compute_entanglement_entropy(state, [i, j])
    S_ik = self.compute_entanglement_entropy(state, [i, k])
    S_jk = self.compute_entanglement_entropy(state, [j, k])
    S_ijk = self.compute_entanglement_entropy(state, [i, j, k])

    return S_i + S_j + S_k - S_ij - S_ik - S_jk + S_ijk

# Add methods to class
BrickworkCircuit.run_single_timestep = run_single_timestep
BrickworkCircuit._compute_syndrome = _compute_syndrome
BrickworkCircuit.run_trajectory = run_trajectory
BrickworkCircuit.compute_entanglement_entropy = compute_entanglement_entropy
BrickworkCircuit.compute_mutual_information = compute_mutual_information
BrickworkCircuit.compute_tripartite_information = compute_tripartite_information

"""Target States and Stabilizer Metrics"""

class TargetStates:
    """Collection of target entangled states"""

    @staticmethod
    def ghz_state(L: int) -> Statevector:
        """Create GHZ state: (|00...0⟩ + |11...1⟩) / √2"""
        qc = QuantumCircuit(L)
        qc.h(0)
        for i in range(L-1):
            qc.cx(i, i+1)
        return Statevector(qc)

    @staticmethod
    def cluster_state_1d(L: int) -> Statevector:
        """Create 1D cluster state"""
        qc = QuantumCircuit(L)
        for i in range(L):
            qc.h(i)
        for i in range(L-1):
            qc.cz(i, i+1)
        return Statevector(qc)

    @staticmethod
    def w_state(L: int) -> Statevector:
        """Create W state"""
        state_vector = np.zeros(2**L, dtype=complex)
        for i in range(L):
            basis_idx = 1 << i
            state_vector[basis_idx] = 1.0 / np.sqrt(L)
        return Statevector(state_vector)


class StabilizerMetrics:
    """Compute metrics for stabilizer state analysis"""

    @staticmethod
    def state_fidelity_simple(state: Statevector, target: Statevector) -> float:
        """Compute fidelity F = |⟨ψ_target|ψ_current⟩|²"""
        return state_fidelity(state, target)

    @staticmethod
    def stabilizer_overlap_ghz(state: Statevector, L: int) -> float:
        """Compute overlap with GHZ state"""
        target = TargetStates.ghz_state(L)
        return StabilizerMetrics.state_fidelity_simple(state, target)

    @staticmethod
    def stabilizer_overlap_cluster(state: Statevector, L: int) -> float:
        """Compute overlap with cluster state"""
        target = TargetStates.cluster_state_1d(L)
        return StabilizerMetrics.state_fidelity_simple(state, target)

print("✓ TargetStates and StabilizerMetrics defined!")

# Test it
print("\nTesting target states:")
circuit_test = BrickworkCircuit(CircuitParams(L=6, p_u=0.5, p_m=0.3))

state_ghz = circuit_test.initialize_near_ghz(noise_level=0.1)
overlap_ghz = StabilizerMetrics.stabilizer_overlap_ghz(state_ghz, 6)
print(f"✓ Near-GHZ overlap: {overlap_ghz:.4f} (should be 0.7-0.9)")

state_random = circuit_test.initialize_random_entangled()
overlap_random = StabilizerMetrics.stabilizer_overlap_ghz(state_random, 6)
print(f"✓ Random overlap: {overlap_random:.4f} (should be 0.0-0.2)")

print("\n✓ All initialization methods working!")

"""Oracle Controller"""

class OracleController:
    """Generate oracle labels for supervised learning"""

    def __init__(self, target_type: str = 'GHZ'):
        self.target_type = target_type

    def generate_oracle_labels(self, circuit, state: Statevector, L: int) -> dict:
        """For current state, determine optimal action"""
        current_overlap = self._compute_overlap(state, L)

        best_action = {'type': 'do_nothing'}
        best_overlap = current_overlap

        # Try applying gates on a few bonds
        for i in [0, L//2, L-2]:
            if i >= L-1:
                continue
            j = i + 1

            try:
                state_copy = state.copy()
                state_new = circuit._apply_two_qubit_gate(state_copy, i, j)
                overlap = self._compute_overlap(state_new, L)

                if overlap > best_overlap:
                    best_overlap = overlap
                    best_action = {'type': 'apply_gate', 'qubits': (i, j)}
            except:
                pass

        return {
            'action': best_action,
            'expected_overlap': best_overlap,
            'improvement': best_overlap - current_overlap
        }

    def _compute_overlap(self, state: Statevector, L: int) -> float:
        """Compute overlap with target state"""
        if self.target_type == 'GHZ':
            return StabilizerMetrics.stabilizer_overlap_ghz(state, L)
        elif self.target_type == 'cluster':
            return StabilizerMetrics.stabilizer_overlap_cluster(state, L)
        else:
            return 0.0

    def should_halt(self, state: Statevector, L: int, threshold: float = 0.95) -> bool:
        """Determine if target state is reached"""
        overlap = self._compute_overlap(state, L)
        return overlap >= threshold

"""Two-Phase Dataset Generation"""

def generate_two_phase_datasets(
    phase: str = 'both',
    L_values: List[int] = [6, 8],
    quick_test: bool = False  # Set to False for full training
):
    """Generate datasets for both training phases"""

    datasets = {}

    # PHASE 1: MAINTENANCE
    if phase in ['maintain', 'both']:
        print("\n" + "="*70)
        print("PHASE 1: Generating MAINTENANCE Dataset")
        print("="*70)

        if quick_test:
            config_maintain = {
                'L_values': [6],
                'p_u_range': [0.5, 0.7],
                'p_m_range': [0.3, 0.5],
                'num_trajectories': 5,
                'num_steps': 20
            }
        else:
            config_maintain = {
                'L_values': L_values,
                'p_u_range': [0.3, 0.5, 0.7, 0.9],
                'p_m_range': [0.1, 0.3, 0.5, 0.7],
                'num_trajectories': 100,
                'num_steps': 30
            }

        dataset_maintain = []
        oracle = OracleController(target_type='GHZ')

        total = (len(config_maintain['L_values']) *
                len(config_maintain['p_u_range']) *
                len(config_maintain['p_m_range']) *
                config_maintain['num_trajectories'])

        count = 0

        for L in config_maintain['L_values']:
            for p_u in config_maintain['p_u_range']:
                for p_m in config_maintain['p_m_range']:
                    for traj_idx in range(config_maintain['num_trajectories']):
                        count += 1

                        params = CircuitParams(L=L, p_u=p_u, p_m=p_m)
                        circuit = BrickworkCircuit(params)

                        state = circuit.initialize_near_ghz(noise_level=0.15)
                        initial_overlap = oracle._compute_overlap(state, L)

                        history = []
                        oracle_actions = []
                        overlaps = [initial_overlap]
                        halt_decisions = []

                        for step in range(config_maintain['num_steps']):
                            try:
                                oracle_output = oracle.generate_oracle_labels(circuit, state, L)
                                oracle_actions.append(oracle_output['action'])
                            except:
                                oracle_actions.append({'type': 'do_nothing'})

                            should_halt = oracle.should_halt(state, L, threshold=0.95)
                            halt_decisions.append(should_halt)

                            state, record = circuit.run_single_timestep(state, step)

                            overlap = oracle._compute_overlap(state, L)
                            overlaps.append(overlap)
                            history.append(record)

                            if should_halt and step > 10:
                                break

                        dataset_maintain.append({
                            'phase': 'maintain',
                            'L': L,
                            'p_u': p_u,
                            'p_m': p_m,
                            'trajectory_idx': traj_idx,
                            'num_steps': len(history),
                            'initial_overlap': initial_overlap,
                            'measurements': [h['measurements'] for h in history],
                            'syndromes': [h['syndrome'] for h in history],
                            'gates_applied': [h['gates_applied'] for h in history],
                            'oracle_actions': oracle_actions,
                            'halt_decisions': halt_decisions,
                            'overlaps': overlaps,
                            'final_overlap': overlaps[-1],
                            'degradation': initial_overlap - overlaps[-1],
                            'stabilization_time': len(overlaps) if overlaps[-1] > 0.95 else None
                        })

                        if count % 20 == 0:
                            print(f"Progress: {count}/{total} | L={L}, p_u={p_u:.1f}, p_m={p_m:.1f} | "
                                  f"Init={initial_overlap:.3f} → Final={overlaps[-1]:.3f}")

        datasets['maintain'] = dataset_maintain
        print(f"\n✓ Phase 1: {len(dataset_maintain)} trajectories")
        print(f"   Mean initial overlap: {np.mean([d['initial_overlap'] for d in dataset_maintain]):.3f}")
        print(f"   Mean final overlap: {np.mean([d['final_overlap'] for d in dataset_maintain]):.3f}")

    # PHASE 2: CREATION
    if phase in ['create', 'both']:
        print("\n" + "="*70)
        print("PHASE 2: Generating CREATION Dataset")
        print("="*70)

        if quick_test:
            config_create = {
                'L_values': [6],
                'p_u_range': [0.7, 0.9],
                'p_m_range': [0.1, 0.3],
                'num_trajectories': 5,
                'num_steps': 30
            }
        else:
            config_create = {
                'L_values': L_values,
                'p_u_range': [0.5, 0.7, 0.9],
                'p_m_range': [0.1, 0.3],
                'num_trajectories': 200,
                'num_steps': 50
            }

        dataset_create = []
        oracle = OracleController(target_type='GHZ')

        total = (len(config_create['L_values']) *
                len(config_create['p_u_range']) *
                len(config_create['p_m_range']) *
                config_create['num_trajectories'])

        count = 0

        for L in config_create['L_values']:
            for p_u in config_create['p_u_range']:
                for p_m in config_create['p_m_range']:
                    for traj_idx in range(config_create['num_trajectories']):
                        count += 1

                        params = CircuitParams(L=L, p_u=p_u, p_m=p_m)
                        circuit = BrickworkCircuit(params)

                        state = circuit.initialize_plus_state()
                        initial_overlap = oracle._compute_overlap(state, L)

                        history = []
                        oracle_actions = []
                        overlaps = [initial_overlap]
                        halt_decisions = []

                        for step in range(config_create['num_steps']):
                            try:
                                oracle_output = oracle.generate_oracle_labels(circuit, state, L)
                                oracle_actions.append(oracle_output['action'])
                            except:
                                oracle_actions.append({'type': 'do_nothing'})

                            should_halt = oracle.should_halt(state, L, threshold=0.95)
                            halt_decisions.append(should_halt)

                            state, record = circuit.run_single_timestep(state, step)

                            overlap = oracle._compute_overlap(state, L)
                            overlaps.append(overlap)
                            history.append(record)

                            if should_halt:
                                break

                        dataset_create.append({
                            'phase': 'create',
                            'L': L,
                            'p_u': p_u,
                            'p_m': p_m,
                            'trajectory_idx': traj_idx,
                            'num_steps': len(history),
                            'initial_overlap': initial_overlap,
                            'measurements': [h['measurements'] for h in history],
                            'syndromes': [h['syndrome'] for h in history],
                            'gates_applied': [h['gates_applied'] for h in history],
                            'oracle_actions': oracle_actions,
                            'halt_decisions': halt_decisions,
                            'overlaps': overlaps,
                            'final_overlap': overlaps[-1],
                            'improvement': overlaps[-1] - initial_overlap,
                            'stabilization_time': len(overlaps) if overlaps[-1] > 0.95 else None
                        })

                        if count % 20 == 0:
                            print(f"Progress: {count}/{total} | L={L}, p_u={p_u:.1f}, p_m={p_m:.1f} | "
                                  f"Init={initial_overlap:.3f} → Final={overlaps[-1]:.3f}")

        datasets['create'] = dataset_create
        print(f"\n✓ Phase 2: {len(dataset_create)} trajectories")
        print(f"   Mean initial overlap: {np.mean([d['initial_overlap'] for d in dataset_create]):.3f}")
        print(f"   Mean final overlap: {np.mean([d['final_overlap'] for d in dataset_create]):.3f}")

    return datasets

"""Generate Test Data Set"""

print("\n" + "="*70)
print("GENERATING QUICK TEST DATASETS")
print("="*70)
print("Note: Set quick_test=False for full training!")
print("="*70)

datasets_test = generate_two_phase_datasets(
    phase='both',
    L_values=[6],
    quick_test= False
)

print("\n✓ Test datasets generated!")
print(f"  Phase 1 (Maintain): {len(datasets_test.get('maintain', []))} trajectories")
print(f"  Phase 2 (Create): {len(datasets_test.get('create', []))} trajectories")

"""Set Up Pytorch"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader

print(f"✓ PyTorch version: {torch.__version__}")
print(f"✓ CUDA available: {torch.cuda.is_available()}")

device = 'cuda' if torch.cuda.is_available() else 'cpu'
print(f"✓ Using device: {device}")

"""Neural Network Controller"""

class QuantumControllerLSTM(nn.Module):
    """LSTM-based controller for quantum circuit control"""

    def __init__(self, L: int = 8, d_model: int = 128, num_layers: int = 3, dropout: float = 0.1):
        super().__init__()
        self.L = L
        self.d_model = d_model

        # Input embedding
        self.measurement_embed = nn.Linear(L, d_model // 2)
        self.syndrome_embed = nn.Linear(L, d_model // 4)
        self.param_embed = nn.Linear(2, d_model // 4)

        # LSTM backbone
        self.lstm = nn.LSTM(
            input_size=d_model,
            hidden_size=d_model,
            num_layers=num_layers,
            batch_first=True,
            dropout=dropout if num_layers > 1 else 0
        )

        # Output heads
        self.action_head = nn.Sequential(
            nn.Linear(d_model, 128),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(128, 3)
        )

        self.qubit_head = nn.Sequential(
            nn.Linear(d_model, 128),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(128, L - 1)
        )

        self.halt_head = nn.Sequential(
            nn.Linear(d_model, 64),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(64, 1),
            nn.Sigmoid()
        )

        self.overlap_predictor = nn.Sequential(
            nn.Linear(d_model, 64),
            nn.ReLU(),
            nn.Linear(64, 1),
            nn.Sigmoid()
        )

    def forward(self, measurements, syndromes, params, return_overlap=False):
        batch, time, L = measurements.shape

        m_embed = self.measurement_embed(measurements.float())
        s_embed = self.syndrome_embed(syndromes.float())
        p_embed = self.param_embed(params).unsqueeze(1).expand(-1, time, -1)

        x = torch.cat([m_embed, s_embed, p_embed], dim=-1)
        h, _ = self.lstm(x)

        actions = self.action_head(h)
        qubits = self.qubit_head(h)
        halt = self.halt_head(h)

        if return_overlap:
            overlap = self.overlap_predictor(h)
            return actions, qubits, halt, overlap

        return actions, qubits, halt

    def get_num_params(self):
        return sum(p.numel() for p in self.parameters() if p.requires_grad)

# Test model
model_test = QuantumControllerLSTM(L=6, d_model=128, num_layers=3)
print(f"✓ Model created with {model_test.get_num_params():,} parameters")

# Test forward pass
batch_size, time, L = 4, 10, 6
measurements = torch.randint(0, 2, (batch_size, time, L)).float()
syndromes = torch.randint(0, 2, (batch_size, time, L)).float()
params = torch.rand(batch_size, 2)

actions, qubits, halt = model_test(measurements, syndromes, params)
print(f"✓ Forward pass successful!")
print(f"  Actions: {actions.shape}, Qubits: {qubits.shape}, Halt: {halt.shape}")

"""Pytorch Dataset"""

class QuantumTrajectoryDataset(Dataset):
    """PyTorch Dataset for quantum trajectories"""

    def __init__(self, trajectories, max_length=50):
        self.trajectories = trajectories
        self.max_length = max_length

    def __len__(self):
        return len(self.trajectories)

    def __getitem__(self, idx):
        traj = self.trajectories[idx]
        L = traj['L']
        T = min(len(traj['measurements']), self.max_length)

        measurements = torch.zeros(self.max_length, L)
        for t, meas_list in enumerate(traj['measurements'][:T]):
            for qubit, outcome in meas_list:
                measurements[t, qubit] = outcome

        syndromes = torch.zeros(self.max_length, L)
        for t, syndrome in enumerate(traj['syndromes'][:T]):
            syndromes[t] = torch.from_numpy(syndrome)

        action_labels = torch.zeros(self.max_length, dtype=torch.long)
        qubit_labels = torch.zeros(self.max_length, dtype=torch.long)

        for t, action in enumerate(traj['oracle_actions'][:T]):
            if action['type'] == 'do_nothing':
                action_labels[t] = 0
            elif action['type'] == 'apply_gate':
                action_labels[t] = 1
                i, j = action['qubits']
                qubit_labels[t] = min(i, j)
            elif action['type'] == 'remeasure':
                action_labels[t] = 2
                qubit_labels[t] = action.get('qubit', 0)

        halt_labels = torch.zeros(self.max_length)
        for t, should_halt in enumerate(traj['halt_decisions'][:T]):
            halt_labels[t] = float(should_halt)

        overlaps = torch.zeros(self.max_length)
        for t, overlap in enumerate(traj['overlaps'][:T]):
            overlaps[t] = overlap

        params = torch.tensor([traj['p_u'], traj['p_m']], dtype=torch.float32)

        mask = torch.zeros(self.max_length, dtype=torch.bool)
        mask[:T] = True

        return {
            'measurements': measurements,
            'syndromes': syndromes,
            'params': params,
            'action_labels': action_labels,
            'qubit_labels': qubit_labels,
            'halt_labels': halt_labels,
            'overlaps': overlaps,
            'mask': mask,
            'length': T
        }

# Test dataset
if 'maintain' in datasets_test:
    dataset_test = QuantumTrajectoryDataset(datasets_test['maintain'], max_length=30)
    print(f"✓ Dataset created with {len(dataset_test)} trajectories")

    sample = dataset_test[0]
    print(f"✓ Sample shape: measurements={sample['measurements'].shape}")

    dataloader = DataLoader(dataset_test, batch_size=4, shuffle=True)
    batch = next(iter(dataloader))
    print(f"✓ DataLoader batch: {batch['measurements'].shape}")

"""Training Functions"""

def train_controller(
    model,
    dataset,
    phase='maintain',
    epochs=100,
    lr=1e-3,
    batch_size=32,
    device='cuda' if torch.cuda.is_available() else 'cpu'
):
    """Train the quantum controller"""

    model = model.to(device)
    model.train()

    train_dataset = QuantumTrajectoryDataset(dataset, max_length=50)
    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    scheduler = torch.optim.lr_scheduler.CosineAnnealingWarmRestarts(
    optimizer,
    T_0=20,      # Restart every 20 epochs
    T_mult=2,    # Double the period after each restart
    eta_min=1e-6 # Minimum learning rate
)


    # Loss weights
    if phase == 'maintain':
        w_action, w_qubit, w_halt, w_overlap, w_sparsity = 1.0, 0.5, 1.0, 0.5, 0.1
    else:
        w_action, w_qubit, w_halt, w_overlap, w_sparsity = 1.0, 0.5, 0.5, 1.0, 0.05

    print(f"\n{'='*70}")
    print(f"TRAINING PHASE: {phase.upper()}")
    print(f"{'='*70}")
    print(f"Dataset: {len(dataset)} trajectories")
    print(f"Epochs: {epochs}, LR: {lr}, Batch: {batch_size}, Device: {device}")
    print(f"{'='*70}\n")

    best_loss = float('inf')

    for epoch in range(epochs):
        total_loss = 0
        total_action_acc = 0
        total_samples = 0

        for batch in train_loader:
            measurements = batch['measurements'].to(device)
            syndromes = batch['syndromes'].to(device)
            params = batch['params'].to(device)
            action_labels = batch['action_labels'].to(device)
            qubit_labels = batch['qubit_labels'].to(device)
            halt_labels = batch['halt_labels'].to(device)
            overlaps = batch['overlaps'].to(device)
            mask = batch['mask'].to(device)

            actions_pred, qubits_pred, halt_pred, overlap_pred = model(
                measurements, syndromes, params, return_overlap=True
            )

            # Action classification loss
            L_action = F.cross_entropy(
                actions_pred[mask].view(-1, 3),
                action_labels[mask].view(-1),
                reduction='mean'
            )

            # Qubit selection loss
            action_mask = (action_labels != 0) & mask
            if action_mask.sum() > 0:
                L_qubit = F.cross_entropy(
                    qubits_pred[action_mask],
                    qubit_labels[action_mask],
                    reduction='mean'
                )
            else:
                L_qubit = torch.tensor(0.0, device=device)

            # Halt decision loss
            L_halt = F.binary_cross_entropy(
                halt_pred[mask].squeeze(),
                halt_labels[mask],
                reduction='mean'
            )

            # Overlap prediction loss
            L_overlap = F.mse_loss(
                overlap_pred[mask].squeeze(),
                overlaps[mask],
                reduction='mean'
            )

            # Sparsity loss
            action_probs = F.softmax(actions_pred, dim=-1)
            high_overlap_mask = (overlaps > 0.9) & mask

            if high_overlap_mask.sum() > 0:
                do_nothing_probs = action_probs[:, :, 0]
                L_sparsity = -do_nothing_probs[high_overlap_mask].mean()
            else:
                L_sparsity = torch.tensor(0.0, device=device)

            # Total loss
            loss = (w_action * L_action +
                   w_qubit * L_qubit +
                   w_halt * L_halt +
                   w_overlap * L_overlap +
                   w_sparsity * L_sparsity)

            # Backward pass
            optimizer.zero_grad()
            loss.backward()
            torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)
            optimizer.step()

            # Track metrics
            total_loss += loss.item()
            action_pred_labels = actions_pred[mask].argmax(dim=-1)
            action_acc = (action_pred_labels == action_labels[mask]).float().mean()
            total_action_acc += action_acc.item()
            total_samples += 1

        # Epoch summary
        avg_loss = total_loss / total_samples
        avg_acc = total_action_acc / total_samples

        old_lr = optimizer.param_groups[0]['lr']
        scheduler.step()
        new_lr = optimizer.param_groups[0]['lr']

        if epoch % 10 == 0 or epoch == epochs - 1:
            print(f"Epoch {epoch:3d}/{epochs} | Loss: {avg_loss:.4f} | "
                  f"Acc: {avg_acc:.3f} | LR: {new_lr:.6f}")

            if new_lr < old_lr:
                print(f"  → Learning rate reduced to {new_lr:.6f}")

        # Save best model
        if avg_loss < best_loss:
            best_loss = avg_loss
            torch.save({
                'epoch': epoch,
                'model_state_dict': model.state_dict(),
                'optimizer_state_dict': optimizer.state_dict(),
                'loss': best_loss,
                'phase': phase
            }, f'best_model_{phase}.pt')

    print(f"\n✓ Training complete! Best loss: {best_loss:.4f}\n")
    return model


def train_two_phase_sequential(datasets, L=6):
    """Train controller in two phases sequentially"""

    print("\n" + "="*70)
    print("TWO-PHASE SEQUENTIAL TRAINING")
    print("="*70)

    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    print(f"Device: {device}")

    # PHASE 1: MAINTENANCE
    print("\n" + "="*70)
    print("PHASE 1: MAINTENANCE TRAINING")
    print("="*70)

    model_phase1 = QuantumControllerLSTM(L=L, d_model=128, num_layers=3)
    print(f"Model parameters: {model_phase1.get_num_params():,}")

    if 'maintain' in datasets:
        model_phase1 = train_controller(
            model=model_phase1,
            dataset=datasets['maintain'],
            phase='maintain',
            epochs=100,  # Increase to 100 for full training
            lr=1e-3,
            batch_size=32,  # Increase to 32 for full training
            device=device
        )
        print("✓ Phase 1 complete!")
    else:
        print("⚠ No maintenance dataset found")

    # PHASE 2: CREATION
    print("\n" + "="*70)
    print("PHASE 2: CREATION TRAINING (Transfer Learning)")
    print("="*70)

    model_phase2 = QuantumControllerLSTM(L=L, d_model=128, num_layers=3)

    if 'create' in datasets:
        try:
            checkpoint = torch.load('best_model_maintain.pt', map_location=device)
            model_phase2.load_state_dict(checkpoint['model_state_dict'])
            print("✓ Loaded Phase 1 weights")
        except:
            print("⚠ Training Phase 2 from scratch")

        model_phase2 = train_controller(
            model=model_phase2,
            dataset=datasets['create'],
            phase='create',
            epochs=150,  # Increase to 150 for full training
            lr=5e-4,
            batch_size=32,  # Increase to 32 for full training
            device=device
        )
        print("✓ Phase 2 complete!")
    else:
        print("⚠ No creation dataset found")

    print("\n" + "="*70)
    print("TWO-PHASE TRAINING COMPLETE!")
    print("="*70)

    return model_phase1, model_phase2

print("✓ Training functions defined!")

"""Execute Full Training!"""

print("\n" + "="*70)
print("COMPLETE TWO-PHASE TRAINING PIPELINE")
print("="*70)

# Train on test datasets
print("\n>>> Training on datasets...")
model_phase1, model_phase2 = train_two_phase_sequential(datasets_test, L=6)
print("TRAINING COMPLETE!")





